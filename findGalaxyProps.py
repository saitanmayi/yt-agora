'''
Find the properties of the galaxy found within a halo over time.
The Most Massive Progenitor Branch (MMPB) properties of the halo 
are needed as input.
'''
import os, sys, argparse
from glob import glob
import numpy as np
from visnap.general.halo_particles import axis_ratios


def parse():
    '''
    Parse command line arguments
    ''' 
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                     description='''\
                                 Find the properties of the galaxy found within a halo over time.
                                 The Most Massive Progenitor Branch (MMPB) properties of the halo
                                 are needed as input.                            
                                 ''')
 
    parser.add_argument('sim_dirs', nargs='+', help='Simulation directories to be analyzed.')

    
    parser.add_argument('-s', '--snap_base', default='10MpcBox_csf512_',
                        help='Base of the snapshots file names.') 

    parser.add_argument('-c', '--center', default='hist',
                        help='The location to use as the center of the stellar component. Can be '\
                             "'max_dens' (for the location of the maximum stellar density), 'com' "\
                            "(for the center of mass), or 'hist' (for a iteratively refined mass "\
                            "weighted histogram).")

    parser.add_argument( '--mmpb_file', default='sim_dir/analysis/catalogs/*_mmpb_props.npy',
                        help='File containig the Most Massive Progenitor branch properties. '\
                             'A python dictionary is expected as generated by findHostandMMPB.py.')

    parser.add_argument('--out_dir',default='sim_dir/analysis/catalogs/',
                        help='Directory where the output will be placed.') 

    args = vars(parser.parse_args())
    return args


def find_hist_center(positions, masses):
    '''
    Find the center of a particle distribution by interatively refining 
    a mass weighted histogram
    '''
    pos = np.array(positions)
    masses = np.array(masses)
    if len(pos) == 0: 
        return None
    mass_current = masses
    old_center = np.array([0,0,0])
    refined_pos = pos.copy()
    refined_mas = mass_current.copy()
    refined_dist = 1e20
    nbins=3
    center = None

    dist = lambda x,y:np.sqrt(np.sum((x-y)**2.0))
    dist2 = lambda x,y:np.sqrt(np.sum((x-y)**2.0,axis=1))

    j=0
    while len(refined_pos)>1e1 or j==0: 
        table,bins=np.histogramdd(refined_pos, bins=nbins, weights=refined_mas)
        bin_size = min((np.max(bins,axis=1)-np.min(bins,axis=1))/nbins)
        centeridx = np.where(table==table.max())
        le = np.array([bins[0][centeridx[0][0]],
                       bins[1][centeridx[1][0]],
                       bins[2][centeridx[2][0]]])
        re = np.array([bins[0][centeridx[0][0]+1],
                       bins[1][centeridx[1][0]+1],
                       bins[2][centeridx[2][0]+1]])
        center = 0.5*(le+re)
        refined_dist = dist(old_center,center)
        old_center = center.copy()
        idx = dist2(refined_pos,center)<bin_size
        refined_pos = refined_pos[idx]
        refined_mas = refined_mas[idx]
        j+=1    

    return center


def find_shapes(stars_center, stars_pos, galaxy_props, ds, n_rad=10, rmax=None):
    '''
    Find the shape of the stellar component at n_rad different radii, 
    spanning from 0.1*rmax to rmax, where rmax = max(star_pos).
    This routine updates the galaxy_props dictionary.
    '''

    print 'Starting shape calculation'

    units = stars_center.units
    stars_center = stars_center.value

    try:
        stars_pos = np.array([stars_pos[:,0] - stars_center[0],
                              stars_pos[:,1] - stars_center[1],
                              stars_pos[:,2] - stars_center[2]]).transpose()
        stars_pos = ds.arr(stars_pos, units)
        stars_pos = stars_pos.in_units('kpc').value
        stars_r = np.sqrt(stars_pos[:,0]**2 + stars_pos[:,1]**2 + stars_pos[:,2]**2)
    except IndexError: # no stars found
        stars_pos = np.array([])   

    if len(stars_pos) > 1: 
        if not rmax: rmax = stars_r.max()
        radii = np.linspace(0.1*rmax, rmax, n_rad)
    else:
        radii = np.array([])
    
    c_to_a = np.empty(radii.size)     
    b_to_a = np.empty(radii.size)
    mass_profile = np.empty(radii.size)
    shape_axes = []
        
    for i,r in enumerate(radii):
        # get shapes
        try:
            axis_out = axis_ratios(stars_pos, r, axes_out=True, fix_volume = False)
            c_to_a[i] = axis_out[0][0]
            b_to_a[i] = axis_out[0][1]
            shape_axes.append(axis_out[1])
        except UnboundLocalError:
            print 'Not enough stars to find shapes at r = %g in snapshot %s'%(r, ds.parameter_filename )
            b_to_a[i] = c_to_a[i] = None
            shape_axes.append([])
        
        # get mass profile
        sphere = ds.sphere(ds.arr(stars_center, units), (r, 'kpc'))
        stars_mass = sphere[('stars', 'particle_mass')].in_units('Msun/h')
        mass_profile[i] = stars_mass.sum().value[()]
           
    galaxy_props['stars_c_to_a'].append((radii, c_to_a))
    galaxy_props['stars_b_to_a'].append((radii, b_to_a))    
    galaxy_props['stars_shape_axes'].append((radii, shape_axes))
    galaxy_props['stars_mass_profile'].append((radii, mass_profile))

def L_crossing(x, y, z, vx, vy, vz, weight, center):
    x, y, z = x-center[0], y-center[1],z-center[2]
    cx, cy, cz = y*vz - z*vy, z*vx - x*vz, x*vy - y*vx
    lx, ly, lz = [np.sum(l * weight) for l in [cx, cy, cz]]
    L = np.array([lx, ly, lz])
    L /= np.sqrt(np.sum(L*L))
    return L


if __name__ == "__main__":

    args = parse()

    import yt

    print '\nStarting '+ sys.argv[0]
    print 'Parsed arguments: '
    print args
    print

    # Get parsed values
    sim_dirs, snap_base = args['sim_dirs'], args['snap_base']
    print 'Analyzing ', sim_dirs

    out_dir = args['out_dir']
    modify_outdir = 0
    if  'sim_dir' in out_dir: 
        out_dir = out_dir.replace('sim_dir','')
        modify_outdir = 1 

    mmpb_file = args['mmpb_file']
    modify_mmpb_file = 0
    if  'sim_dir' in mmpb_file: 
        mmpb_file = mmpb_file.replace('sim_dir','')
        modify_mmpb_file = 1

    center = args['center']    
        
    # Loop over simulation directories    
    for sim_dir in sim_dirs:
        
        # Set paths and filenames
        sim_dir = os.path.expandvars(sim_dir)
        sim_dir = os.path.abspath(sim_dir)

        if modify_outdir:  out_dir = sim_dir+'/'+out_dir
        if modify_mmpb_file: mmpb_file = sim_dir+'/'+mmpb_file

        if not os.path.exists(out_dir): os.makedirs(out_dir)

        # Get the MMPB properties
        mmpb_files = glob(mmpb_file)
        if len(mmpb_files) > 1:
            print 'More than one file matches %s, '\
                'the suplied file name for the MMPB properties. '\
                'Set which file you want to use with --mmpb_file'\
                % (mmpb_file)
            sys.exit()
        else:
            mmpb_file = mmpb_files[0]
            mmpb_props = np.load(mmpb_file)[()] 
    
        # Generate data series
        snaps = glob(sim_dir+'/'+snap_base+'*')
        ts = yt.DatasetSeries(snaps)

        # Initialize galaxy properties dictionary 
        galaxy_props = {}
        fields = ['scale', 'stars_total_mass', 'stars_com', 'stars_maxdens', 'stars_hist_center',
                  'stars_mass_profile', 'stars_c_to_a', 'stars_b_to_a', 'stars_shape_axes', 
                  'stars_L', 'gas_total_mass', 'gas_maxdens', 'gas_L']
        for field in fields: 
            if field in ['scale', 'stars_total_mass', 'gas_total_mass' ]:
                galaxy_props[field] = np.array([])                
            else :
                galaxy_props[field] = []
        
        # Loop over snapshots
        for ds in reversed(ts):

            scale = round(1.0/(ds.current_redshift+1.0),4)
            if scale not in mmpb_props['scale']:
                continue

            galaxy_props['scale'] = np.append(galaxy_props['scale'], scale)
            idx = np.argwhere(mmpb_props['scale'] == scale)[0][0]

            # Generate sphere selection
            halo_center = ds.arr([mmpb_props['x'][idx], mmpb_props['y'][idx],
                                  mmpb_props['z'][idx]], 'Mpccm/h')
            halo_rvir = mmpb_props['rvir'][idx]
            halo_rs = mmpb_props['rs'][idx]
            sphere = ds.sphere(halo_center, (halo_rvir, 'kpccm/h'))

            # Get total star mass 
            stars_mass = sphere[('stars', 'particle_mass')].in_units('Msun/h')
            stars_total_mass = stars_mass.sum().value[()]
            galaxy_props['stars_total_mass'] = np.append(galaxy_props['stars_total_mass'],
                                                         stars_total_mass)

            # Get center of mass of stars
            stars_pos_x = sphere[('stars', 'particle_position_x')].in_units('Mpccm/h')
            stars_pos_y = sphere[('stars', 'particle_position_y')].in_units('Mpccm/h')
            stars_pos_z = sphere[('stars', 'particle_position_z')].in_units('Mpccm/h')
            stars_com = np.array([np.dot(stars_pos_x, stars_mass)/stars_total_mass, 
                                  np.dot(stars_pos_y, stars_mass)/stars_total_mass, 
                                  np.dot(stars_pos_z, stars_mass)/stars_total_mass])
            galaxy_props['stars_com'].append(stars_com)
            
            # Get max density of stars (value, location)
            stars_maxdens = sphere.quantities.max_location(('deposit', 'stars_density'))
            stars_maxdens_val = stars_maxdens[0].in_units('Msun*h**2/kpccm**3').value[()]
            stars_maxdens_loc = np.array([stars_maxdens[2].in_units('Mpccm/h').value[()], 
                                          stars_maxdens[3].in_units('Mpccm/h').value[()], 
                                          stars_maxdens[4].in_units('Mpccm/h').value[()]])
            galaxy_props['stars_maxdens'].append((stars_maxdens_val, stars_maxdens_loc))

            # Get refined histogram center of stars
            stars_pos = np.array([stars_pos_x, stars_pos_y, stars_pos_z]).transpose()
            stars_hist_center = find_hist_center(stars_pos, stars_mass)
            galaxy_props['stars_hist_center'].append(stars_hist_center)

            # Define center of stars
            if center == 'max_dens': stars_center = stars_maxdens_loc
            elif center == 'com': stars_center = stars_com
            else: stars_center = stars_hist_center
            stars_center = ds.arr(stars_center, 'Mpccm/h')

            # Get shapes of stars
            find_shapes(stars_center, stars_pos, galaxy_props, ds, 10, 25.0)

            # Get angular momentum of stars
            sc_sphere =  ds.sphere(stars_center, (halo_rs, 'kpccm/h'))
            try:
                x, y, z = [sc_sphere[('stars', 'particle_position_%s'%s)] for s in 'xyz'] 
                vx, vy, vz = [sc_sphere[('stars', 'particle_velocity_%s'%s)] for s in 'xyz'] 
                mass = sc_sphere[('stars', 'particle_mass')]
                metals = sc_sphere[('stars', 'particle_metallicity')]
                stars_L = L_crossing(x, y, z, vx, vy, vz, mass*metals, sc_sphere.center)
            except IndexError: # no stars found
                stars_L = [None, None, None]
            galaxy_props['stars_L'].append(stars_L)
            del(sc_sphere)

            # Get total mass of gas
            gas_mass = sphere[('gas', 'cell_mass')].in_units('Msun/h')
            gas_total_mass = gas_mass.sum().value[()]
            galaxy_props['gas_total_mass'] = np.append(galaxy_props['gas_total_mass'], 
                                                       gas_total_mass)
            
            # Get max density of gas
            gas_maxdens = sphere.quantities.max_location(('gas', 'density'))
            gas_maxdens_val = gas_maxdens[0].in_units('Msun*h**2/kpccm**3').value[()]
            gas_maxdens_loc = np.array([gas_maxdens[2].in_units('Mpccm/h').value[()], 
                                        gas_maxdens[3].in_units('Mpccm/h').value[()], 
                                        gas_maxdens[4].in_units('Mpccm/h').value[()]])
            galaxy_props['gas_maxdens'].append((gas_maxdens_val, gas_maxdens_loc)) 
            
            gas_center = ds.arr(gas_maxdens_loc, 'Mpccm/h')

            # Get angular momentum of gas
            gc_sphere =  ds.sphere(gas_center, (halo_rs, 'kpccm/h'))
            x, y, z = [gc_sphere[('index', '%s'%s)] for s in 'xyz'] 
            vx, vy, vz = [gc_sphere[('gas', 'momentum_%s'%s)] for s in 'xyz'] # momentum density
            cell_volume = gc_sphere[('index', 'cell_volume')]
            metals = gc_sphere[('gas', 'metal_ia_density')] + gc_sphere[('gas', 'metal_ii_density')]
            gas_L = L_crossing(x, y, z, vx, vy, vz, metals*cell_volume**2, gc_sphere.center)
            galaxy_props['gas_L'].append(gas_L)
            del(gc_sphere)
                               
            del(sphere)                    

        # Save galaxy props
        galaxy_props_file = mmpb_file.replace('mmpb', 'galaxy')    
        print '\nSuccefully computed galaxy properties'
        print 'Saving galaxy properties to ', galaxy_props_file
        print
        np.save(galaxy_props_file, galaxy_props)     
