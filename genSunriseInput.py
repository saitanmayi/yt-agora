'''
Generate .fits file containing the simulation data in a format that
Sunrise uderstands. Also generate the configuration files required 
to run Sunrise. 
'''
import os, sys, argparse
from glob import glob
import numpy as np
from collections import OrderedDict

if __name__ != "__main__":
    from yt.analysis_modules.sunrise_export import sunrise_exporter
    from yt.analysis_modules.halo_finding.halo_objects import RockstarHaloList 
    yt.enable_parallelism()

import pdb


def parse():
    '''
    Parse command line arguments
    ''' 
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                     description='''\
                                Generate .fits file containing the simulation data in a format that
                                Sunrise uderstands. Also generate the configuration files required 
                                to run Sunrise.
                                ''')
 
    parser.add_argument('sim_dirs', nargs='+', help='Simulation directories to be analyzed.')
    
    parser.add_argument('-s', '--snap_base', default='10MpcBox_csf512_',
                        help='Base of the snapshots file names.') 

    parser.add_argument('-d', '--distance', default=100, type=float,
                        help='Distance between cameras and the center of the galaxy (in [kpc]).')

    parser.add_argument('-f', '--fov', default=50, type=float,
                        help='Field of view of the cameras at the image plane (in [kpc]).') 

    parser.add_argument('--star_particles', default='stars',
                        help='The name given to the star particles in the yt dataset '\
                        '(as printed in ds.field_list or ds.derived_field_list).') 

    parser.add_argument('--dm_particles', default='darkmatter',
                        help='The name given to the dark matter particles in the yt dataset '\
                        '(as printed in ds.field_list or ds.derived_field_list).') 

    parser.add_argument( '--galprops_file', default='sim_dir/analysis/catalogs/*_galaxy_props.npy',
                        help='File containig the galaxy properties. A python dictionary is expected '\
                             'as generated by findGalaxyProps.py.')

    parser.add_argument('--out_dir',default='sim_dir/analysis/sunrise_input/',
                        help='Directory where the output will be placed.') 

    parser.add_argument('--no_plots',action='store_true',
                        help='Do not generate projection plots.') 

    parser.add_argument('--no_export',action='store_true',
                        help='Do not export data to fits for Sunrise.') 

    args = vars(parser.parse_args())
    return args


def generate_cameras(normal_vector, distance=100.0, fov=50.0):
    '''
    Set camera positions and orientations
    '''
    from yt.utilities.orientation import Orientation

    print "\nGenerating cameras"
    
    north = np.array([0.,1.,0.])
    orient = Orientation(normal_vector=normal_vector, north_vector=north)
    R=np.linalg.inv(orient.inv_mat)

    camera_set = OrderedDict([
            ['face',([0.,0.,1.],[0.,-1.,0],True)], #up is north=+y
            ['edge',([0.,1.,0.],[0.,0.,-1.],True)],#up is along z
            ['45',([0.,0.7071,0.7071],[0., 0., -1.],True)],
            ['Z-axis',([0.,0.,1.],[0.,-1.,0],False)], #up is north=+y
            ['Y-axis',([0.,1.,0.],[0.,0.,-1.],False)],#up is along z
            ])  
    segments = 5
    np.random.seed(0)
    ts = np.random.random(segments)*np.pi*2
    ps = np.random.random(segments)*np.pi-np.pi/2.0
    for i,(theta, phi) in enumerate(zip(ts,ps)):
        pos = [np.cos(theta),0.,np.sin(phi)]
        vc  = [np.cos(np.pi/2.-theta),0.,np.sin(np.pi/2.-phi)] 
        camera_set['Random_%03i'%(i)]=(pos,vc,False)

    i=0    
    cameras = OrderedDict()
    for name,(normal,north,do_rot)  in camera_set.iteritems():
        orient = Orientation(normal_vector=normal, north_vector=north)
        if do_rot:
            drot = R.copy()
        else:
            drot = np.identity(3)
        sunrise_pos = np.dot(orient.normal_vector, drot)
        sunrise_up  = L.copy()
        if np.all(np.abs(sunrise_up-sunrise_pos)<1e-3):
            sunrise_up[0] *= 0.5 
        sunrise_direction = -1.0*sunrise_pos
        sunrise_afov = 2.0*np.arctan((fov/2.0)/distance)
        norm = lambda x: x/np.sqrt(np.sum(x*x))
        if np.all(np.abs(norm(sunrise_up)-norm(sunrise_pos))<1e-3):
            sunrise_up[0]*=0.5
            sunrise_up = norm(sunrise_up)
        line = (distance*sunrise_pos, distance*sunrise_direction, sunrise_up,
                sunrise_afov, fov, distance) 
        cameras[name] = line
        i+=1

    print "Succesfully generated cameras\n"
    return cameras


def write_cameras(prefix, cameras):
    print "Writing cameras to ",  prefix+'.cameras'
    fn = prefix+'.cameras'
    campos = ()
    for name,row in cameras.iteritems():
        campos += (tuple(row[1])+tuple(row[0])+tuple(row[2])+tuple([row[3]]),)
    campos = np.array(campos)
    np.savetxt(fn, campos)   
    fn = prefix+'.camnames'
    fh = open(fn,'w')
    fh.write('\n'.join([c for c in cameras.keys()]))
    fh.close()


def plot_particles(prefix, ds, center, cameras, 
                   dm_particles='darkmatter', star_particles='stars',
                   file_halo=None, camslice=['edge','face','zoom']):
    """
    Project DM on the fov, 200kpc and 1mpc scale for camera 0
        circling halos
    Slice stellar density once through camera 1
    Project stars for every camera, using the FOV, circling halos
    """
    camnames = cameras.keys()
    cams = [cameras[n] for n in camnames]

    if file_halo:
        halo_list = RockstarHaloList(ds, file_halo) 
    else:
        halo_list = None

    for i,(name,cam) in enumerate(cameras.iteritems()):               
        offaxisprojection(prefix+'_cam%02i_fov'%i, ds, cam, center, 
                          particle_type=star_particles,
                          halo_list=halo_list)    
        '''    
        offaxisprojection(prefix+'_cam%02i_fov'%i, ds, cam, center,
                          particle_type=star_particles, 
                          halo_list=halo_list,
                          field=star_particles+'_Vlos')
        offaxisprojection(prefix+'_cam%02i_fov'%i, ds, cam, center, 
                          particle_type=star_particles,
                          halo_list=halo_list,
                          field=star_particles+'_Age')    
        '''       
        offaxisprojection(prefix+'_cam%02i_fov'%i, ds, cam, center,
                          particle_type=dm_particles,
                          halo_list=halo_list)
        if camslice in name:
            offaxisprojection(prefix+'_cam%02i_fov'%i, ds, cam, center,
                              particle_type=star_particles,
                              halo_list=halo_list, slice=True)
    offaxisprojection(prefix+'_'+camname[0]+'_fov', ds, cams[0], center, 
                      particle_type=dm_particles,
                      halo_list=halo_list)
    offaxisprojection(prefix+'_'+camname[0]+'_200Kpc', ds, cams[0], center,
                      particle_type=dm_particles,
                      fov=200, halo_list=halo_list, min_mass=1e9)
    offaxisprojection(prefix+'_'+camname[0]+'_2Mpccm', ds, cams[0], center,
                      particle_type=dm_particles,
                      fov=ds.ds.arr(2.0, 'Mpccm').in_units('kpc'),
                      halo_list=halo_list, min_mass=1e10)
   


def offaxisprojection(prefix, ds, camera, center, field='density',
                      particle_type='darkmatter', fov=None,
                      slice=False, halo_list=None, min_mass=1e8):

    center = center.in_units('kpc')
    normal, distance, up, width = get_camprops(camera)
    if fov is not None:
        width = fov
    width = ds.arr(width, 'kpc')  
    distance = ds.arr(distance, 'kpc') 

    LeftEdge, RightEdge = center - distance/2.0, center + distance/2.0 
    box = ds.box(LeftEdge, RightEdge)

    weight = ('deposit', particle_type+'_density')
    if field == 'density': 
        field = ('deposit', particle_type+'_density')
        weight = None
    elif field in [ particle_type+'_Vlos', particle_type+'_Age']: 
        add_particle_los_fields(box, normal, particle_type)  

    if slice:
        p=yt.OffAxisSlicePlot(box.ds, normal, field, 
                              center.in_units('code_length'),
                              width=(width.value, width.units),
                              north_vector=up)
    else:
        p=yt.OffAxisProjectionPlot(box.ds, normal, field, 
                                   center.in_units('code_length'),
                                   width=(width.value, width.units),
                                   depth=(2*distance.value, distance.units),
                                   north_vector=up, 
                                   weight_field=weight)
    if halo_list:
        p.annotate_hop_circles(halo_list, annotate=True, 
                               fixed_radius=(1.0, 'kpc'),
                               max_number=int(1e9),
                               min_mass=min_mass, min_size=1e-99,
                               width=(2*width.value, width.units))
    if yt.is_root():
        p.save(prefix)


def add_particle_los_fields(box, normal, particle_type):

    def _Vlos(field, data):
        vx, vy, vz = (data[(particle_type, 'particle_velocity_%s'%ax)].in_units('km/s') for ax in 'xyz')
        vlos = vx*normal[0] + vy*normal[1] + vz*normal[2]
        return vlos 

    def _Age(field, data):
        age = (box.ds.current_time - data[(particle_type, 'particle_creation_time')]).in_units('Myr')
        return age
        
    box.ds.add_field(particle_type+"_Vlos",
                     function=_Vlos,
                     take_log=False,
                     display_name = r'$\rm{LOS\ Velocity\ (km/s)}$',
                     force_override=True,
                     units='km/s')

    box.ds.add_field(particle_type+"_Age",
                     function=_Age,
                     take_log=False,
                     display_name = r'$\rm{Age (Myr)}$',
                     force_override=True,
                     units='Myr')


def plot_gas(prefix, ds, center, cameras, camslice='edge_zoom'):

    field = 'density'
    for i, (name, cam) in enumerate(cameras.iteritems()):
        normal, distance, up, width = get_camprops(cam)
        p=OffAxisProjectionPlot(ds, normal, field, 
                                center.in_units('code_length'), 
                                width=(width, 'kpc'),
                                depth=(2*distance, 'kpc'),
                                north_vector=up)
        if yt.is_root():
            p.save(prefix+'_cam%02i_fov'%i)
        if camslice in name:
            p=OffAxisSlicePlot(ds, normal, ['metal_ia_density'], center, 
                               width=(width, 'kpc'), north_vector=up)
            if yt.is_root():
                p.save(prefix+'_cam%02i_fov'%i)

    def _MetalMass(field, data):
        return (data['metal_ia_density']*data['cell_volume']).in_units('Msun')
    ds.add_field('MetalMass', function=_MetalMass, units='Msun')         
    
    def _Temperature(field, data):
        te = data['thermal_energy']
        hd = data['H_nuclei_density']
        temp = (2.0*te/(3.0*hd*yt.physical_constants.kb)).in_units('K')
        return temp
    ds.add_field('Temperature', function=_Temperature, units='K')

    sph = ds.sphere(center, (20.0, 'kpc'))
    
    pc = PlotCollection(ds, center=center)
    pc.add_phase_object(sph, ["density","Temperature","cell_mass"])
    pc.set_unit('density', 'Msun/kpc**3')
    pc.set_unit('cell_mass', 'Msun')
    if yt.is_root:
        pc.save(prefix+'_phase_Temp_GasMass')
    
    pc = PlotCollection(ds, center=center)
    pc.add_phase_object(sph, ["density","Temperature","MetalMass"])
    pc.set_unit('density', 'Msun/kpc**3')
    if yt.is_root:
        pc.save(prefix+'_phase_Temp_MetalMass')
    

def get_camprops(cam):
    normal = np.array(cam[0])
    pos = np.array(cam[1])
    up = np.array(cam[2])
    afov = np.array(cam[3])
    distance=np.sqrt(np.sum(pos**2.0))
    fov= cam[4]
    return normal,distance,up,fov


def export_fits(ds, center, export_radius, prefix, star_particles):
    '''
    Convert the contents of a dataset to a FITS file format that Sunrise
    understands.
    '''

    print "\nExporting data to FITS for Sunrise"

    filename = prefix+'.fits'
    center = center.in_units('kpc')
    width = export_radius.in_units('kpc')
    info = {}
      
    fle,fre,ile,ire,dd,nleafs,nstars = \
        sunrise_exporter.export_to_sunrise(ds, filename, star_particles, center, width)
    info['export_ile']=ile
    info['export_ire']=ire
    info['export_fle']=fle
    info['export_fre']=fre
    info['export_nleafs']=nleafs
    info['export_nstars']=nstars

    print "Succefully generated FITS for Sunrise"
    print info,'\n'
    return info


if __name__ == "__main__":

    args = parse()

    import yt
    from yt.analysis_modules.sunrise_export import sunrise_exporter
    from yt.analysis_modules.halo_finding.halo_objects import RockstarHaloList  
    yt.enable_parallelism()
    
    if yt.is_root():
        print '/nStarting '+ sys.argv[0]
        print 'Parsed arguments: '
        print args
        print

    # Get parsed values
    sim_dirs, snap_base = args['sim_dirs'], args['snap_base']
    print 'Analyzing ', sim_dirs

    out_dir = args['out_dir']
    modify_outdir = 0
    if  'sim_dir' in out_dir: 
        out_dir = out_dir.replace('sim_dir','')
        modify_outdir = 1 

    galprops_file = args['galprops_file']
    modify_galprops_file = 0
    if  'sim_dir' in galprops_file: 
        galprops_file = galprops_file.replace('sim_dir','')
        modify_galprops_file = 1

    cam_dist, cam_fov = float(args['distance']), float(args['fov'])  
    star_particles, dm_particles = args['star_particles'], args['dm_particles']
    no_plots, no_export = args['no_plots'], args['no_export']
        
    # Loop over simulation directories    
    for sim_dir in sim_dirs:
        
        # Set paths and filenames
        sim_dir = os.path.expandvars(sim_dir)
        sim_dir = os.path.abspath(sim_dir)

        if modify_outdir:  out_dir = sim_dir+'/'+out_dir
        if modify_galprops_file: galprops_file = sim_dir+'/'+galprops_file
        
        if yt.is_root():
            if not os.path.exists(out_dir): os.makedirs(out_dir)

        # Get the galaxy properties
        galprops_files = glob(galprops_file)
        if len(galprops_files) > 1:
            print 'More than one file matches %s, '\
                'the suplied file name for the galaxy properties. '\
                'Set which file you want to use with --galprops_file'\
                % (galprops_file)
            sys.exit()
        else:
            galprops_file = galprops_files[0]
            galprops = np.load(galprops_file)[()] 

        # Generate data series
        snaps = glob(sim_dir+'/'+snap_base+'*')
        ts = yt.DatasetSeries(snaps)
         
        # Loop over snapshots 
        for ds in reversed(ts):

            scale = round(1.0/(ds.current_redshift+1.0),4)
            if scale not in galprops['scale']:
                continue

            idx = np.argwhere(galprops['scale'] == scale)[0][0]

            # Set camera positions and orientations
            stars_L = galprops['stars_L'][idx]
            gas_L = galprops['gas_L'][idx]
            L_sum = stars_L + gas_L
            L = L_sum/np.sqrt(np.sum(L_sum*L_sum))
            cameras = generate_cameras(L, distance=cam_dist, fov=cam_fov)    
    
            # Write cameras to file
            scale_dir = out_dir+'a'+str(scale)+'/'
            prefix = galprops_file.replace('galaxy_props.npy', 'a'+str(scale)).split('/')[-1] 
            prefix = scale_dir+prefix
            if yt.is_root():
                if not os.path.exists(scale_dir): os.makedirs(scale_dir)
                write_cameras(prefix, cameras)

            gal_center = ds.arr(galprops['stars_hist_center'][idx], 'Mpccm/h')
            
              # Make plots
            if not no_plots:
                plot_particles(prefix, ds, gal_center, cameras, 
                               dm_particles=dm_particles, 
                               star_particles=star_particles,
                               file_halo=None, camslice='edge_zoom')
                plot_gas(prefix, ds, center, cameras, camslice='edge_zoom')

            # Export fits files with the data for Sunrise
            if not no_export:
                export_radius = ds.arr(max(1.2*cam_dist, 1.2*cam_fov), 'kpc')
                export_info = export_fits(ds, gal_center, export_radius, 
                                          prefix, star_particles)



